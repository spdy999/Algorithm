# Accounts Merge - Leetcode 721 - Python

![rw-book-cover](https://i.ytimg.com/vi/6st4IxEF-90/maxresdefault.jpg)

## Metadata
- Author: [[NeetCodeIO]]
- Full Title: Accounts Merge - Leetcode 721 - Python
- Category: #articles
- Summary: üöÄ https://neetcode.io/ - A better way to prepare for Coding Interviews

ü•∑ Discord: https://discord.gg/ddjKRXPqtk
üê¶ Twitter: https://twitter.com/neetcode1

üêÆ Support the channel: https://www.patreon.com/NEETcode

‚≠ê BLIND-75 PLAYLIST: https://www.youtube.com/watch?v=KLlXCFG5TnA&list=PLot-Xpze53ldVwtstag2TL4HQhAnC8ATf
üí° DYNAMIC PROGRAMMING PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1

Problem Link: https://leetcode.com/problems/accounts-merge/

0:00 - Read the problem
0:50 - Drawing Explanation
10:10 - Coding Explanation

leetcode 721

#neetcode #leetcode #python
- URL: https://www.youtube.com/watch?v=6st4IxEF-90

## Full Document
Hey everyone, welcome back, and let'swrite some more neat code today. So today,let's solve the problem of accounts merge.We're given a list of accounts whereeach account is a list of strings. Thefirst string is always going to be thename of the account, and then everystring following that is going to be anemail. The problem is that there could bemultiple accounts that belong to thesame person. If that's the case, thesemultiple accounts will have the exactsame name, but they could have adifferent set of emails. But we will knowthat these two accounts belong to thesame person if they have at least asingle email in common‚Äîat least one ormore emails in common. So one of theemails that shows up in this account hasto also show up in this account or viceversa. That means that these two accountsbelonged to the same person. Now justbecause two accounts have the same name

doesn't necessarily mean they belong tothe same person. At the same time, twoaccounts that belong to the same personwill always have the same name. That kindof makes it a bit tricky, but we're gonnaneed these observations to solve thisproblem. So after we take two accountsThat belong to the same person and mergethem together. We then want to take, like,a single account. It's going to still bea list of strings where the first stringis going to be the name of the person,and then every string after that isgoing to be the email of the person, andthe emails themselves should be sortedin ascending order. That's the outputthat we want to return. So it's not asimple problem. Even solving the problemin the most brute force way possibleisn't easy. Let me try to describe thatto you, and then I'll show you how we canoptimize that solution a bit.

Then I'll show you the final solution, whichis going to be about the same timecomplexity as the optimal solution. So wehave a list of accounts. If we have, like,a nested for loop where we compare everypair of accounts, and then for those twoaccounts, let's say A1 and A2, then we tryto see if there's any common emailsbetween them. If there are, then thatmeans these two accounts belong to thesame person. And then later we might findthat actually this account also belongsto this person. So that means, like, thesetwo accounts were connected.

These two accounts were also connected,which pretty much means that all threeaccounts belong to the same person. Thisis kind of the intuition that leads youto see that this is a graph problem.

Just the name game itself‚Äî Accounts Merge,merging accounts ‚Äî it leads you tobelieve that this could be a union-findor disjoint set problem, which it is. Butthat is not an easy solution to come upwith; the easier solution is a DFSsolution, which I‚Äôll try to explain toyou. So this is kind of one of the mostbrute force ways to solve it, where wetake all the accounts and put all theaccounts that belong to the same personin disjoint graphs. So maybe thesetwo belong to the same person‚Äî A3 and A4‚Äîpossibly also belong to the same person.There‚Äôs an edge connecting them, andmaybe A5 just belongs to a single person.

Then we would want to run a DFS on eachof these connected components,aggregating all of the emails for eachconnected component, sorting those emails,and also taking the name from oneof these accounts. We know that both ofthese accounts will have the same name,since they belong to the same person. Sowe would take a name and then append allOf these emails, which we sort, and thenthat will pretty much give us the outputthat we want would look something likethis down here. So this is a less optimalway to do it. We can take this strategyand actually make it more optimal.

Instead of taking accounts andconnecting them, we can actually dosomething even more bare bones where weactually just skip to the emailsthemselves. We take all of the emailsthat belong to the same person andcreate disjoint sets with them. So, like,this could be a disjoint set, and then wecould add others, so we know that allthese emails belong to the same person.We would run a DFS on them and do prettymuch what I described earlier. I won‚Äôt gosuper in-depth into this solutionbecause I‚Äôm not going to code it up, butI‚Äôll say that the overall timecomplexity of this is going to be thesame as the union-find solution that I‚Äômgoing to show you. I think this problemis a natural union-find problem, sothat‚Äôs what I‚Äôm going to be going with.

But I‚Äôll also admit that it‚Äôs not supereasy to come up with. This isn‚Äôt a typeof problem where if you know it‚Äôs unionfind, that you can immediately solve it.

It's still not easy, so I'll explain it to you now. Suppose we have a bunch ofaccounts: A1, A2, A3, with Union.Fine, what we want to do is find accountswith the same owners and then merge themtogether, pretty much what I showed earlier.How exactly can we do this? Well,if we iterate through every singleaccount, we're going to get a list of itsemails. We want to know if an emailbelongs to multiple accounts. The easiestway to do that is iterate through allthe emails, take each email, and map it to theaccount index. So let's say, account index,we could have also done the account name,but that wouldn't work, and you'll kind of see why.

We need the account index, and then later,maybe we're going through account number two.We're going through all of its emails, and then we find anemail that we've already inserted intoour hashmap. This is what we're going todo: we're going to take each email, map itto the account index that it belongs to.If we ever see an email that alreadyexists in the hashmap, that must mean itbelongs to multiple accounts. So we'regoing to take the current index thatwe're at, like the current account index,that we're at. Let's say it's equal toTwo accounts previously mapped to the sameemail and maybe accountindex one. So now we know that accountindex one and account index two belong tothe same person because they have anemail in common. So what we‚Äôre going todo is union these two accounts togetherin our Union-Find data structure. Let‚Äôsjust assume we have that because that‚Äôsnot what I really want to explain.

This problem is hard enough;hopefully, you do have a decentunderstanding of Union-Find. If not, thereare other videos on my channel thatexplain it. So by the end of doing all ofthis, we will have our disjoint sets.

Maybe A1 and A2 belong to the sameperson, while A3 and A4 belong to the sameperson as well. Now with thisinformation, what are we going to do? Well,once again, we‚Äôre going to iteratethrough all of the emails that we have.

Now we don‚Äôt care so much about theaccount index, though we actually aregoing to use the account index that wemapped each email to. But we‚Äôre going totake that account index and, using ourUnion-Find data structure, remember Union-Find has two operations: unioning twodisjoint sets together or finding theRoot parent, or AKA the leader,is the leader of that disjoint set because eachdisjoint set will have a leader. I'mdrawing them like this, but in reality, adisjoint set is drawn like this wheremaybe A1 is the leader and A2 overhere is the child. So why do we want to findthe leader? It's because for every email itbelongs to a single person. We need aunique identifier for that person, andwe're going to use the index of thatleader account. So our find operation

will give us exactly that, the index ofthis account. In this case, let's say it'sone, and then using this index, we want tomap this email to it. So we're going tosay index one has this list of emailsand we'll be able to do that for everysingle email. Every email will now bemapped to a single account; it won't havemultiple accounts. It'll have a singleaccount; that's why we're doing this findoperation. We just want to have a singleaccount that aggregates all of theemails that belong to it. You canprobably see by now that if we have that, ifwe have a mapping, so maybe account onehas all of these emails, and account twobelongs to the same person, therefore,it's actually not going to have any.

Emails we don‚Äôt even care about thisanymore, but maybe account three is theleader of the other disjoint set, and ithas another set of emails. So, possibly, westarted with four accounts: one, two, three,four, but now we‚Äôre only left with twoaccounts because these are the actualaccounts after we‚Äôve merged all of theaccounts. We will make sure to sortthe emails and have the name go at thebeginning of the array, just like theywant us to do in the output. So, that‚Äôspretty much how we‚Äôre going to solvethis problem. If you still don‚Äôtentirely understand it, this was just theintuition. Now, let‚Äôs actually code it upand see how it works, and then we‚Äôll talkabout the time complexity as well. So I‚Äômgoing to skip writing out the union findbecause it‚Äôs mostly just boilerplate.

This is like standard union find thatyou would write in any type of problem;if you know it, then you know it. We haveour constructor where we‚Äôre passing inthe number of nodes that we have. In thiscase, we‚Äôre going to pass in the numberof accounts. So, let me actually just dothat right now. We‚Äôre going to constructa union find instance, passing in thelength of our accounts array.

Just going to call this UF for short, andit supports two operations: finding theroot of a given node or value in thisdata structure. We're doing pathcompression, which is going to make bothof these operations basically run inconstant time. We also have the unionoperation, which is going to useour rank, which is also known as the size ofeach of our disjoint sets. Initially,each of them has a size of one, andinitially, each of their parents is goingto be itself. But as we union thedisjoint sets together, the parents mightchange. So we're going to be unioning byrank. That means the set with fewer nodesis going to be the child of the set withmore nodes, and then we would update therank accordingly. So the parent is theone whose rank is going to increase.Now let's actually get into this problem,not the union-find specific stuff. So wehave our Union-Find instance. What wewant to do, remember, is map every singleemail to the account, more specifically,each email to the index of the accountthat it belongs to. Now, when we iteratethrough each account, which I'm going to dolike this in Python, you can enumerateThe value at the same time, so I is the

index A, is the account. Then we want togo through every email in the account,but remember, the first value of theaccount array is going to be the name. Wewant to skip that, so we're going tostart at index one, which is going togive us the emails. Now, there are two caseshere. What if the email already exists inthe hash map? That's one case, and theother case is if it doesn‚Äôt. So thesecond one is the simpler case: if itdoesn't exist in the hash map, let‚Äôs justgo ahead and add it. So email to accountat this email is going to be mapped tothis index. Now, otherwise, that means thisemail not only belongs to this accountat index I, but it also belongs towhatever index that we insertedpreviously. So, we can get that by justtaking this. I'm going to copy and pastethat. So these two indices, a.k.a. these twoaccounts should be merged together. Theybelong to the same person; they have anemail in common, so they belong to thesame person. We're going to take ourUnion-Find data structure and unionthese two together. Once all of that‚Äôsdone, we will have our disjoint sets. Butwhat are we going to do with them?

For every single email, it should belongto a single account. So, we want to createthose accounts, a.k.a. those email groups. Wewant to. I'm going to create a defaultdict. This is a hash map that will have adefault value of a list because what wewant to do now is take each index of theaccount and map it to its list of emails.Now, this won't necessarily have everysingle account because if multipleaccounts belong to the same person, wewant to merge them together. So, this willbe that merged set. But for every singlegroup of accounts, we have to identify asingle account that's going to basicallyact as the leader after we merge themtogether. So, I'm going to iterate throughour previous hash map that we created,which will give us every single emailand the account index that it belongs to.

I'm going to change this to be a bitshorter. I'm just going to call it 'e' sowe can iterate through that hashmap likethis: email to account dot items, becausewe want the key and the value, which I'mgetting here. So, we want the leader ofthis account. So, we're going to say Unionfind dot find. I could be the leaderitself, or it could have a differentleader, but basically, we want a singleAccount that‚Äôs going to act as theleader, and for our email group, we wantto then map this leader and then appendto it this email. So for every account, wewant to get all of the emails thatbelong to it. That‚Äôs basically what we‚Äôredoing here. It might make sense when yousee it now, but it‚Äôs definitely not easyto come up with. I do admit that this ismore of a hard problem. I think now,lastly, once you get this far, you canprobably figure out what you need to do.

We‚Äôve basically taken the accounts andmerged them together. Now we just need toget the output in the format that theywant us to. So I‚Äôm going to create ourresult; it‚Äôs going to be a list of lists.

So now we‚Äôre going to go through everyindex of the account and list of emailsin the hashmap email group that we justcreated. Dot items are going to give usthe key-value pairs, and then we want thename. We already have the list ofemails, but we want the name from theaccount. How do we get that? While ouroriginal accounts array a at index i andthe first value at index 0 is going togive us the name of that account, andthen we just want to result.append to itthis name array plus the email group at.

Index I is going to give us thelist of emails that belong to thisaccount, and don't forget to actuallysort them. So, I'm going to sort them here.Lastly, what this is doing, I'll brieflyexplain it. If this is a list, andclearly this is a list in Python, you canbasically do array concatenation. So,that's kind of what I'm doing here, justto make it look a bit more readable.Maybe it's less readable, but that's whatthis is doing here. And after we've donethat, we can go ahead and return theresult. So, this is 45 lines of code. Ihope it makes sense. Let's run it to makesure that it works, and as you can see,yes, it does, and it's pretty efficient. Ifthis was helpful, please like andsubscribe. If you're preparing for codinginterviews, check out neat code.io. It hasa ton of free resources to help youprepare. Thanks for watching, andhopefully, I'll see you pretty soon.
